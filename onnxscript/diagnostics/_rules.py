"""
GENERATED CODE - DO NOT EDIT DIRECTLY
This file is generated by gen_diagnostics.py.
See tools/gen_diagnostics.py for more information.

Diagnostic rules for PyTorch ONNX export.
"""

import dataclasses
from typing import Tuple

# flake8: noqa
from onnxscript.diagnostics import infra

"""
GENERATED CODE - DO NOT EDIT DIRECTLY
The purpose of generating a class for each rule is to override the `format_message`
method to provide more details in the signature about the format arguments.
"""


class _ONNXScriptConvertSuccess(infra.Rule):
    """FX Tracer succeeded."""

    def format_message(self, fn_name, tracer_name) -> str:  # type: ignore[override]
        """Returns the formatted default message of this Rule.

        Message template: "The aten op '{op_name}' is successfully converted to onnxscript graph '{torchlib_function_name}'."
        """
        return self.message_default_template.format(
            fn_name=fn_name, tracer_name=tracer_name
        )

    def format(  # type: ignore[override]
        self, level: infra.Level, fn_name, tracer_name
    ) -> Tuple[infra.Rule, infra.Level, str]:
        """Returns a tuple of (Rule, Level, message) for this Rule.

        Message template: "The aten op '{op_name}' is successfully converted to onnxscript graph '{torchlib_function_name}'."
        """
        return (
            self,
            level,
            self.format_message(fn_name=fn_name, tracer_name=tracer_name),
        )


class _ONNXScriptConvertFailure(infra.Rule):
    """FX Tracer failed."""

    def format_message(  # type: ignore[override]
        self, fn_name, tracer_name, explanation
    ) -> str:
        """Returns the formatted default message of this Rule.

        Message template: "The aten op '{op_name}' failed to be converted to onnxscript graph '{torchlib_function_name}'."
        """
        return self.message_default_template.format(
            fn_name=fn_name, tracer_name=tracer_name, explanation=explanation
        )

    def format(  # type: ignore[override]
        self, level: infra.Level, fn_name, tracer_name, explanation
    ) -> Tuple[infra.Rule, infra.Level, str]:
        """Returns a tuple of (Rule, Level, message) for this Rule.

        Message template: "The aten op '{op_name}' failed to be converted to onnxscript graph '{torchlib_function_name}'."
        """
        return (
            self,
            level,
            self.format_message(
                fn_name=fn_name, tracer_name=tracer_name, explanation=explanation
            ),
        )


class _FxNodeToOnnx(infra.Rule):
    """Node level tracking. ToDo, experimenting diagnostics, placeholder text."""

    def format_message(  # type: ignore[override]
        self,
    ) -> str:
        """Returns the formatted default message of this Rule.

        Message template: 'ToDo, experimenting diagnostics, placeholder text.'
        """
        return self.message_default_template.format()

    def format(  # type: ignore[override]
        self,
        level: infra.Level,
    ) -> Tuple[infra.Rule, infra.Level, str]:
        """Returns a tuple of (Rule, Level, message) for this Rule.

        Message template: 'ToDo, experimenting diagnostics, placeholder text.'
        """
        return self, level, self.format_message()


class _NoSymbolicFunctionForCallFunction(infra.Rule):
    """Cannot find symbolic function to convert the "call_function" FX node to ONNX."""

    def format_message(self, target) -> str:  # type: ignore[override]
        """Returns the formatted default message of this Rule.

        Message template: 'No symbolic function to convert the "call_function" node {target} to ONNX. '
        """
        return self.message_default_template.format(target=target)

    def format(  # type: ignore[override]
        self, level: infra.Level, target
    ) -> Tuple[infra.Rule, infra.Level, str]:
        """Returns a tuple of (Rule, Level, message) for this Rule.

        Message template: 'No symbolic function to convert the "call_function" node {target} to ONNX. '
        """
        return self, level, self.format_message(target=target)


@dataclasses.dataclass
class _POERules(infra.RuleCollection):
    onnxscript_convert_success: _ONNXScriptConvertSuccess = dataclasses.field(
        default=_ONNXScriptConvertSuccess.from_sarif(
            **{
                "id": "POE0001",
                "name": "onnxscript_convert_success",
                "short_description": {"text": "Aten op is converted successfully."},
                "full_description": {
                    "text": "Aten op has been converted to a torchlib function successfully.",
                    "markdown": "Aten op has been converted to a torchlib function successfully.\n",
                },
                "message_strings": {
                    "default": {
                        "text": "Aten op {op_name} has been converted to a torchlib function successfully."
                    }
                },
                "help_uri": None,
                "properties": {"deprecated": False, "tags": []},
            }
        ),
        init=False,
    )
    """Aten op is converted successfully."""

    onnxscript_convert_failure: _ONNXScriptConvertFailure = dataclasses.field(
        default=_ONNXScriptConvertFailure.from_sarif(
            **{
                "id": "POE0002",
                "name": "onnxscript_convert_failure",
                "short_description": {
                    "text": "Aten op failed to be converted to a torchlib function."
                },
                "full_description": {
                    "text": "Aten op could not be converted to a torchlib function.",
                    "markdown": "Aten op could not be converted to a torchlib function.\n",
                },
                "message_strings": {
                    "default": {
                        "text": "Aten op {op_name} could not be converted to a torchlib function."
                    }
                },
                "help_uri": None,
                "properties": {"deprecated": False, "tags": []},
            }
        ),
        init=False,
    )
    """Aten op failed to be converted to a torchlib function."""

    fx_node_to_onnx: _FxNodeToOnnx = dataclasses.field(
        default=_FxNodeToOnnx.from_sarif(
            **{
                "id": "FXE0008",
                "name": "fx-node-to-onnx",
                "short_description": {
                    "text": "Node level tracking. ToDo, experimenting diagnostics, placeholder text."
                },
                "full_description": {
                    "text": "ToDo, experimenting diagnostics, placeholder text.",
                    "markdown": "ToDo, experimenting diagnostics, placeholder text.\n",
                },
                "message_strings": {
                    "default": {
                        "text": "ToDo, experimenting diagnostics, placeholder text."
                    }
                },
                "help_uri": None,
                "properties": {"deprecated": False, "tags": []},
            }
        ),
        init=False,
    )
    """Node level tracking. ToDo, experimenting diagnostics, placeholder text."""

    no_symbolic_function_for_call_function: _NoSymbolicFunctionForCallFunction = dataclasses.field(
        default=_NoSymbolicFunctionForCallFunction.from_sarif(
            **{
                "id": "FXE0011",
                "name": "no-symbolic-function-for-call-function",
                "short_description": {
                    "text": 'Cannot find symbolic function to convert the "call_function" FX node to ONNX.'
                },
                "full_description": {
                    "text": 'Cannot find symbolic function to convert the "call_function" FX node to ONNX. ',
                    "markdown": 'This error occurs when the ONNX converter is unable to find a corresponding symbolic function\nto convert a "call_function" node in the input graph to its equivalence in ONNX. The "call_function"\nnode represents a normalized function call in PyTorch, such as "torch.aten.ops.add".\n\nTo resolve this error, you can try one of the following:\n\n- If exists, apply the auto-fix suggested by the diagnostic. TODO: this part is not available yet.\n- Rewrite the model using only supported PyTorch operators or functions.\n- Follow this [guide](https://pytorch.org/docs/stable/onnx.html#onnx-script-functions) to write and\n  register a custom symbolic function for the unsupported call_function FX node.\n\nTODO: Replace above link once docs for `dynamo_export` custom op registration are available.\n',
                },
                "message_strings": {
                    "default": {
                        "text": 'No symbolic function to convert the "call_function" node {target} to ONNX. '
                    }
                },
                "help_uri": None,
                "properties": {"deprecated": False, "tags": []},
            }
        ),
        init=False,
    )
    """Cannot find symbolic function to convert the "call_function" FX node to ONNX."""


rules = _POERules()
